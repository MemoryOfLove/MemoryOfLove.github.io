<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="blog" href="http://jluyeyu.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="blog" href="http://jluyeyu.com/atom.xml"><link rel="alternate" type="application/json" title="blog" href="http://jluyeyu.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="react"><link rel="canonical" href="http://jluyeyu.com/react/react%20hooks/"><title>react hooks - react | jluyeyu = blog</title><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">react hooks</h1><div class="meta"><span class="item" title="创建时间：2022-02-11 13:20:52"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-02-11T13:20:52+08:00">2022-02-11</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>9.1k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>8 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">jluyeyu</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipevo9j1jj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclffsa1cj20zk0m811l.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gicli9lfebj20zk0m84qp.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipev1x5e4j20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipexoj0moj20zk0m8kgu.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclwrdwyaj20zk0m8are.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/react/" itemprop="item" rel="index" title="分类于 react"><span itemprop="name">react</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://jluyeyu.com/react/react%20hooks/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="jluyeyu"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="blog"></span><div class="body md" itemprop="articleBody"><h1 id="react-hooks"><a class="anchor" href="#react-hooks">#</a> React Hooks</h1><h2 id="hooks简介"><a class="anchor" href="#hooks简介">#</a> Hooks 简介</h2><p>​	<em>Hook</em> 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。具体而言，分为以下 Hook</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly96aC1oYW5zLnJlYWN0anMub3JnL2RvY3MvaG9va3MtcmVmZXJlbmNlLmh0bWwjYmFzaWMtaG9va3M=">基础 Hook</span><ul><li><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usestate"><code>useState</code></a></li><li><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#useeffect"><code>useEffect</code></a></li><li><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext"><code>useContext</code></a></li></ul></li><li><span class="exturl" data-url="aHR0cHM6Ly96aC1oYW5zLnJlYWN0anMub3JnL2RvY3MvaG9va3MtcmVmZXJlbmNlLmh0bWwjYWRkaXRpb25hbC1ob29rcw==">额外的 Hook</span><ul><li><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer"><code>useReducer</code></a></li><li><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usecallback"><code>useCallback</code></a></li><li><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usememo"><code>useMemo</code></a></li><li><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#useref"><code>useRef</code></a></li><li><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#useimperativehandle"><code>useImperativeHandle</code></a></li><li><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#uselayouteffect"><code>useLayoutEffect</code></a></li><li><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usedebugvalue"><code>useDebugValue</code></a></li></ul></li></ul><h2 id="基础-hook"><a class="anchor" href="#基础-hook">#</a> 基础 Hook</h2><h3 id="usestate"><a class="anchor" href="#usestate">#</a> <code>useState</code></h3><pre><code class="language-react">const [state, setState] = useState(initialState);
</code></pre><p>返回一个 state，以及更新 state 的函数。</p><p>在初始渲染期间，返回的状态 ( <code>state</code> ) 与传入的第一个参数 ( <code>initialState</code> ) 值相同。</p><p><code>setState</code> 函数用于更新 state。它接收一个新的 state 值并将组件的一次重新渲染加入队列。</p><pre><code class="language-react">setState(newState);
//or
setState((value)=&gt;&#123;
    ...
    return newState;
&#125;)
</code></pre><p>在后续的重新渲染中， <code>useState</code> 返回的第一个值将始终是更新后最新的 state。</p><h4 id="函数式更新"><a class="anchor" href="#函数式更新">#</a> 函数式更新</h4><p>如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 <code>setState</code> 。该函数将接收先前的 state，并返回一个更新后的值。下面的计数器组件示例展示了 <code>setState</code> 的两种用法：</p><pre><code class="language-react">function Counter(&#123;initialCount&#125;) &#123;
  const [count, setCount] = useState(initialCount);
  return (
    &lt;&gt;
      Count: &#123;count&#125;
      &lt;button onClick=&#123;() =&gt; setCount(initialCount)&#125;&gt;Reset&lt;/button&gt;
      &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-&lt;/button&gt;
      &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+&lt;/button&gt;
    &lt;/&gt;
  );
&#125;
</code></pre><p>“+” 和 “-” 按钮采用函数式形式，因为被更新的 state 需要基于之前的 state。但是 “重置” 按钮则采用普通形式，因为它总是把 count 设置回初始值。</p><p><strong>如果你的更新函数返回值与当前 state 完全相同，则随后的重渲染会被完全跳过。</strong></p><h4 id="惰性初始-state"><a class="anchor" href="#惰性初始-state">#</a> 惰性初始 state</h4><p><code>initialState</code> 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用：</p><pre><code class="language-react">const [state, setState] = useState(() =&gt; &#123;
  const initialState = someExpensiveComputation(props);
  return initialState;
&#125;);
</code></pre><h3 id="useeffect"><a class="anchor" href="#useeffect">#</a> <code>useEffect</code></h3><pre><code class="language-react">useEffect(didUpdate);
</code></pre><p>该 Hook 接收一个包含命令式、且可能有副作用代码的函数。</p><p>首先说一下什么是副作用，<strong>一个纯函数应该只存在输入到输出的映射，如果有其他的作用，便可称之为副作用</strong>。</p><p>在函数组件主体内（这里指在 React 渲染阶段）<strong>改变 DOM、添加订阅、设置定时器、记录日志、ajax 操作</strong>、 等等都是副作用 **(异步操作、延迟操作都算)**，以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性。</p><p>使用 <code>useEffect</code> 完成副作用操作。赋值给 <code>useEffect</code> 的函数会在组件渲染到屏幕之后执行。</p><p>默认情况下，effect 将在每轮渲染结束后执行，但你可以选择让它 <span class="exturl" data-url="aHR0cHM6Ly96aC1oYW5zLnJlYWN0anMub3JnL2RvY3MvaG9va3MtcmVmZXJlbmNlLmh0bWwjY29uZGl0aW9uYWxseS1maXJpbmctYW4tZWZmZWN0">在只有某些值改变的时候</span> 才执行。</p><h4 id="清除-effect"><a class="anchor" href="#清除-effect">#</a> 清除 effect</h4><p>通常，组件卸载时需要清除 effect 创建的诸如订阅或计时器 ID 等资源。要实现这一点， <code>useEffect</code> 函数需返回一个清除函数。以下就是一个创建订阅的例子：</p><pre><code class="language-react">useEffect(() =&gt; &#123;
  const subscription = props.source.subscribe();
  return () =&gt; &#123;
    // 清除订阅
    subscription.unsubscribe();
  &#125;;
&#125;);
</code></pre><p>为防止内存泄漏，清除函数会在组件卸载前执行。另外，如果组件多次渲染（通常如此），则<strong>在执行下一个 effect 之前，上一个 effect 就已被清除</strong>。在上述示例中，意味着组件的每一次更新都会创建新的订阅。若想避免每次更新都触发 effect 的执行，请参阅下一小节。</p><h4 id="effect-的执行时机"><a class="anchor" href="#effect-的执行时机">#</a> effect 的执行时机</h4><p>与 <code>componentDidMount</code> 、 <code>componentDidUpdate</code> 不同的是，传给 <code>useEffect</code> 的函数会在浏览器完成布局与绘制<strong>之后</strong>，在一个延迟事件中被调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因为绝大多数操作不应阻塞浏览器对屏幕的更新。</p><p>然而，并非所有 effect 都可以被延迟执行。例如，一个对用户可见的 DOM 变更就必须在浏览器执行下一次绘制前被同步执行，这样用户才不会感觉到视觉上的不一致。（概念上类似于被动监听事件和主动监听事件的区别。）React 为此提供了一个额外的 <a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#uselayouteffect"><code>useLayoutEffect</code> </a>Hook 来处理这类 effect。它和 <code>useEffect</code> 的结构相同，区别只是调用时机不同。</p><p>虽然 <code>useEffect</code> 会在浏览器绘制后延迟执行，但会保证在任何新的渲染前执行。在开始新的更新前，React 总会先清除上一轮渲染的 effect。</p><h4 id="effect-的条件执行"><a class="anchor" href="#effect-的条件执行">#</a> effect 的条件执行</h4><p>默认情况下，effect 会在每轮组件渲染完成后执行。这样的话，一旦 effect 的依赖发生变化，它就会被重新创建。</p><p>然而，在某些场景下这么做可能会矫枉过正。比如，在上一章节的订阅示例中，我们不需要在每次组件更新时都创建新的订阅，而是仅需要在 <code>source</code> prop 改变时重新创建。</p><p>要实现这一点，可以给 <code>useEffect</code> 传递第二个参数，它是 effect 所依赖的值数组。更新后的示例如下：</p><pre><code class="language-react">useEffect(
  () =&gt; &#123;
    const subscription = props.source.subscribe();
    return () =&gt; &#123;
      subscription.unsubscribe();
    &#125;;
  &#125;,
  [props.source],
);
</code></pre><p>此时，只有当 <code>props.source</code> 改变后才会重新创建订阅。</p><blockquote><p>注意</p><p>如果你要使用此优化方式，请确保数组中包含了<strong>所有外部作用域中会发生变化且在 effect 中使用的变量</strong>，否则你的代码会引用到先前渲染中的旧变量。请参阅文档，了解更多关于<span class="exturl" data-url="aHR0cHM6Ly96aC1oYW5zLnJlYWN0anMub3JnL2RvY3MvaG9va3MtZmFxLmh0bWwjaXMtaXQtc2FmZS10by1vbWl0LWZ1bmN0aW9ucy1mcm9tLXRoZS1saXN0LW9mLWRlcGVuZGVuY2llcw==">如何处理函数</span> 以及<span class="exturl" data-url="aHR0cHM6Ly96aC1oYW5zLnJlYWN0anMub3JnL2RvY3MvaG9va3MtZmFxLmh0bWwjd2hhdC1jYW4taS1kby1pZi1teS1lZmZlY3QtZGVwZW5kZW5jaWVzLWNoYW5nZS10b28tb2Z0ZW4=">数组频繁变化时的措施</span> 的内容。</p><p>** 如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（ <code>[]</code> ）作为第二个参数。** 这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行。这并不属于特殊情况 —— 它依然遵循输入数组的工作方式。</p><p>如果你传入了一个空数组（ <code>[]</code> ），effect 内部的 props 和 state 就会一直持有其初始值。尽管传入 <code>[]</code> 作为第二个参数有点类似于 <code>componentDidMount</code> 和 <code>componentWillUnmount</code> 的思维模式，但我们有 <span class="exturl" data-url="aHR0cHM6Ly96aC1oYW5zLnJlYWN0anMub3JnL2RvY3MvaG9va3MtZmFxLmh0bWwjaXMtaXQtc2FmZS10by1vbWl0LWZ1bmN0aW9ucy1mcm9tLXRoZS1saXN0LW9mLWRlcGVuZGVuY2llcw==">更好的</span> <span class="exturl" data-url="aHR0cHM6Ly96aC1oYW5zLnJlYWN0anMub3JnL2RvY3MvaG9va3MtZmFxLmh0bWwjd2hhdC1jYW4taS1kby1pZi1teS1lZmZlY3QtZGVwZW5kZW5jaWVzLWNoYW5nZS10b28tb2Z0ZW4=">方式</span> 来避免过于频繁的重复调用 effect。除此之外，请记得 React 会等待浏览器完成画面渲染之后才会延迟调用 <code>useEffect</code> ，因此会使得处理额外操作很方便。</p></blockquote><p>依赖项数组不会作为参数传给 effect 函数。虽然从概念上来说它表现为：所有 effect 函数中引用的值都应该出现在依赖项数组中。未来编译器会更加智能，届时自动创建数组将成为可能。</p><h3 id="usecontext"><a class="anchor" href="#usecontext">#</a> <code>useContext</code></h3><pre><code class="language-react">const value = useContext(MyContext);
</code></pre><p>接收一个 context 对象（ <code>React.createContext</code> 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 <code>&lt;MyContext.Provider&gt;</code> 的 <code>value</code> prop 决定。</p><p>当组件上层最近的 <code>&lt;MyContext.Provider&gt;</code> 更新时，该 Hook 会触发重渲染，并使用最新传递给 <code>MyContext</code> provider 的 context <code>value</code> 值。即使祖先使用 <a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/react-api.html#reactmemo"><code>React.memo</code> </a>或 <a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate</code> </a>，也会在组件本身使用 <code>useContext</code> 时重新渲染。</p><p><code>useContext</code> 的参数必须是 <em>context 对象本身</em>：</p><ul><li><strong>正确：</strong> <code>useContext(MyContext)</code></li><li><strong>错误：</strong> <code>useContext(MyContext.Consumer)</code></li><li><strong>错误：</strong> <code>useContext(MyContext.Provider)</code></li></ul><p>调用了 <code>useContext</code> 的组件总会在 context 值变化时重新渲染。如果重渲染组件的开销较大，你可以 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNTE1NiNpc3N1ZWNvbW1lbnQtNDc0NTkwNjkz">通过使用 memoization 来优化</span>。</p><p><strong>把如下代码与 Context.Provider 放在一起</strong></p><pre><code class="language-react">const themes = &#123;
  light: &#123;
    foreground: &quot;#000000&quot;,
    background: &quot;#eeeeee&quot;
  &#125;,
  dark: &#123;
    foreground: &quot;#ffffff&quot;,
    background: &quot;#222222&quot;
  &#125;
&#125;;

const ThemeContext = React.createContext(themes.light);

function App() &#123;
  return (
    &lt;ThemeContext.Provider value=&#123;themes.dark&#125;&gt;
      &lt;Toolbar /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
&#125;

function Toolbar(props) &#123;
  return (
    &lt;div&gt;
      &lt;ThemedButton /&gt;
    &lt;/div&gt;
  );
&#125;

function ThemedButton() &#123;
  const theme = useContext(ThemeContext);  return (    &lt;button style=&#123;&#123; background: theme.background, color: theme.foreground &#125;&#125;&gt;      I am styled by theme context!    &lt;/button&gt;  );
&#125;
</code></pre><h2 id="额外的-hook"><a class="anchor" href="#额外的-hook">#</a> 额外的 Hook</h2><p>以下介绍的 Hook，有些是上一节中基础 Hook 的变体，有些则仅在特殊情况下会用到。不用特意预先学习它们。</p><h3 id="usereducer"><a class="anchor" href="#usereducer">#</a> <code>useReducer</code></h3><pre><code class="language-react">const [state, dispatch] = useReducer(reducer, initialArg, init);
</code></pre><p><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usestate"><code>useState</code> </a>的替代方案。它接收一个形如 <code>(state, action) =&gt; newState</code> 的 reducer，并返回当前的 state 以及与其配套的 <code>dispatch</code> 方法。（</p><p>在某些场景下， <code>useReducer</code> 会比 <code>useState</code> 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 <code>useReducer</code> 还能给那些会触发深更新的组件做性能优化，因为<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down">你可以向子组件传递 <code>dispatch</code> 而不是回调函数</a> 。</p><p>以下是用 reducer 重写 <a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usestate"><code>useState</code> </a>一节的计数器示例：</p><pre><code class="language-react">const initialState = &#123;count: 0&#125;;

function reducer(state, action) &#123;
  switch (action.type) &#123;
    case 'increment':
      return &#123;count: state.count + 1&#125;;
    case 'decrement':
      return &#123;count: state.count - 1&#125;;
    default:
      throw new Error();
  &#125;
&#125;

function Counter() &#123;
  const [state, dispatch] = useReducer(reducer, initialState);
  return (
    &lt;&gt;
      Count: &#123;state.count&#125;
      &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'decrement'&#125;)&#125;&gt;-&lt;/button&gt;
      &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'increment'&#125;)&#125;&gt;+&lt;/button&gt;
    &lt;/&gt;
  );
&#125;
</code></pre><blockquote><p>注意</p><p>React 会确保 <code>dispatch</code> 函数的标识是稳定的，并且不会在组件重新渲染时改变。这就是为什么可以安全地从 <code>useEffect</code> 或 <code>useCallback</code> 的依赖列表中省略 <code>dispatch</code> 。</p></blockquote><h4 id="指定初始-state"><a class="anchor" href="#指定初始-state">#</a> 指定初始 state</h4><p>有两种不同初始化 <code>useReducer</code> state 的方式，你可以根据使用场景选择其中的一种。将初始 state 作为第二个参数传入 <code>useReducer</code> 是最简单的方法：</p><pre><code class="language-react">  const [state, dispatch] = useReducer(
    reducer,
    &#123;count: initialCount&#125;  );
</code></pre><blockquote><p>注意</p><p>React 不使用 <code>state = initialState</code> 这一由 Redux 推广开来的参数约定。有时候初始值依赖于 props，因此需要在调用 Hook 时指定。如果你特别喜欢上述的参数约定，可以通过调用 <code>useReducer(reducer, undefined, reducer)</code> 来模拟 Redux 的行为，但我们不鼓励你这么做。</p></blockquote><h4 id="惰性初始化"><a class="anchor" href="#惰性初始化">#</a> 惰性初始化</h4><p>你可以选择惰性地创建初始 state。为此，需要将 <code>init</code> 函数作为 <code>useReducer</code> 的第三个参数传入，这样初始 state 将被设置为 <code>init(initialArg)</code> 。</p><p>这么做可以将用于计算 state 的逻辑提取到 reducer 外部，这也为将来对重置 state 的 action 做处理提供了便利：</p><pre><code class="language-react">function init(initialCount) &#123;  return &#123;count: initialCount&#125;;&#125;
function reducer(state, action) &#123;
  switch (action.type) &#123;
    case 'increment':
      return &#123;count: state.count + 1&#125;;
    case 'decrement':
      return &#123;count: state.count - 1&#125;;
    case 'reset':      return init(action.payload);    default:
      throw new Error();
  &#125;
&#125;

function Counter(&#123;initialCount&#125;) &#123;
  const [state, dispatch] = useReducer(reducer, initialCount, init);  return (
    &lt;&gt;
      Count: &#123;state.count&#125;
      &lt;button
        onClick=&#123;() =&gt; dispatch(&#123;type: 'reset', payload: initialCount&#125;)&#125;&gt;        Reset
      &lt;/button&gt;
      &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'decrement'&#125;)&#125;&gt;-&lt;/button&gt;
      &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'increment'&#125;)&#125;&gt;+&lt;/button&gt;
    &lt;/&gt;
  );
&#125;
</code></pre><h4 id="跳过-dispatch"><a class="anchor" href="#跳过-dispatch">#</a> 跳过 dispatch</h4><p>如果 Reducer Hook 的返回值与当前 state 相同，React 将跳过子组件的渲染及副作用的执行。（React 使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description"><code>Object.is</code> 比较算法</a> 来比较 state。）</p><p>需要注意的是，React 可能仍需要在跳过渲染前再次渲染该组件。不过由于 React 不会对组件树的 “深层” 节点进行不必要的渲染，所以大可不必担心。如果你在渲染期间执行了高开销的计算，则可以使用 <code>useMemo</code> 来进行优化。</p><h4 id="通过usecontext和usereducer实现的一种状态管理"><a class="anchor" href="#通过usecontext和usereducer实现的一种状态管理">#</a> 通过 useContext 和 useReducer 实现的一种状态管理</h4><p>考虑如下一种情况，有一个书架组件和阅读组件，书架组件可以上传本地书籍，阅读组件可以阅读上传的本地书籍。在书籍没有上传到后台的情况下，如何实现两组件间的通信 (书籍信息共享) 呢？</p><p>首先先考虑数据挂载在哪？很明显应该挂在两组件的父组件上 (不考虑 redux 时)。那么既然如此，通过 props 的逐层传递是一种解决方案，但是比较麻烦。更为简便的方案就是通过 useContext 和 useReducer 来实现。</p><p>我们可以同通过在其父组件上挂载一个 Context</p><pre><code class="language-react">export const BookListContext = React.createContext();

const reducer = (state, action) =&gt; &#123;
  switch (action.type) &#123;
    case &quot;addBooks&quot;:
      return handleAddBooks(state, action.value);
    case &quot;deleteBooks&quot;:
      return handleDeleteBooks(state, action.value);
    default:
      return state;
  &#125;
&#125;;
&lt;BookListContext.Provider
        value=&#123;&#123;
          bookList: bookList,
          bookListDispatch: dispatch,
        &#125;&#125;
      &gt;
        &lt;Routes&gt;
          &lt;Route path=&quot;/book/:bookName&quot; element=&#123;&lt;Book /&gt;&#125;&gt;&lt;/Route&gt;
          &lt;Route path=&quot;/&quot; element=&#123;&lt;Bookshelf /&gt;&#125;&gt;&lt;/Route&gt;
        &lt;/Routes&gt;
&lt;/BookListContext.Provider&gt;
</code></pre><p>子组件需要时，进行调用</p><pre><code class="language-react">  const bookListContext = useContext(BookListContext);
  const bookList=bookListContext.bookList;
  bookListContext.bookListDispatch(&#123;type:'addBooks',value:fileLists&#125;);
  bookListContext.bookListDispatch(&#123;type:'deleteBooks',value:bookName&#125;);
</code></pre><h3 id="useref"><a class="anchor" href="#useref">#</a> <code>useRef</code></h3><pre><code>const refContainer = useRef(initialValue);
</code></pre><p><code>useRef</code> 返回一个可变的 ref 对象，其 <code>.current</code> 属性被初始化为传入的参数（ <code>initialValue</code> ）。返回的 ref 对象在组件的整个生命周期内持续存在。</p><p>一个常见的用例便是命令式地访问子组件：</p><pre><code class="language-react">function TextInputWithFocusButton() &#123;
  const inputEl = useRef(null);
  const onButtonClick = () =&gt; &#123;
    // `current` 指向已挂载到 DOM 上的文本输入元素
    inputEl.current.focus();
  &#125;;
  return (
    &lt;&gt;
      &lt;input ref=&#123;inputEl&#125; type=&quot;text&quot; /&gt;
      &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt;
    &lt;/&gt;
  );
&#125;
</code></pre><p>本质上， <code>useRef</code> 就像是可以在其 <code>.current</code> 属性中保存一个可变值的 “盒子”。</p><p>你应该熟悉 ref 这一种<span class="exturl" data-url="aHR0cHM6Ly96aC1oYW5zLnJlYWN0anMub3JnL2RvY3MvcmVmcy1hbmQtdGhlLWRvbS5odG1s">访问 DOM</span> 的主要方式。如果你将 ref 对象以 <code>&lt;div ref=&#123;myRef&#125; /&gt;</code> 形式传入组件，则无论该节点如何改变，React 都会将 ref 对象的 <code>.current</code> 属性设置为相应的 DOM 节点。</p><p>然而， <code>useRef()</code> 比 <code>ref</code> 属性更有用。它可以<span class="exturl" data-url="aHR0cHM6Ly96aC1oYW5zLnJlYWN0anMub3JnL2RvY3MvaG9va3MtZmFxLmh0bWwjaXMtdGhlcmUtc29tZXRoaW5nLWxpa2UtaW5zdGFuY2UtdmFyaWFibGVz">很方便地保存任何可变值</span>，其类似于在 class 中使用实例字段的方式。</p><p>这是因为它创建的是一个普通 Javascript 对象。而 <code>useRef()</code> 和自建一个 <code>&#123;current: ...&#125;</code> 对象的唯一区别是， <code>useRef</code> 会在每次渲染时返回同一个 ref 对象。</p><p>请记住，当 ref 对象内容发生变化时， <code>useRef</code> 并<em>不会</em>通知你。变更 <code>.current</code> 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用<span class="exturl" data-url="aHR0cHM6Ly96aC1oYW5zLnJlYWN0anMub3JnL2RvY3MvaG9va3MtZmFxLmh0bWwjaG93LWNhbi1pLW1lYXN1cmUtYS1kb20tbm9kZQ==">回调 ref</span> 来实现。</p><div class="tags"><a href="/tags/react/" rel="tag"><i class="ic i-tag"></i> react</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-02-11 14:11:12" itemprop="dateModified" datetime="2022-02-11T14:11:12+08:00">2022-02-11</time> </span><span id="react/react hooks/" class="item leancloud_visitors" data-flag-title="react hooks" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="jluyeyu 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="jluyeyu 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>jluyeyu <i class="ic i-at"><em>@</em></i>blog</li><li class="link"><strong>本文链接：</strong> <a href="http://jluyeyu.com/react/react%20hooks/" title="react hooks">http://jluyeyu.com/react/react hooks/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/typescript/ts%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclxp31goj20zk0m8qv5.jpg" title="TypeScript学习笔记"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> typescript</span><h3>TypeScript学习笔记</h3></a></div><div class="item right"><a href="/react/create-react-app%E9%85%8D%E7%BD%AEless/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclhpw3lwj20zk0m8gvw.jpg" title="create-react-app配置less"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> react</span><h3>create-react-app配置less</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#react-hooks"><span class="toc-number">1.</span> <span class="toc-text">React Hooks</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#hooks%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">Hooks 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-hook"><span class="toc-number">1.2.</span> <span class="toc-text">基础 Hook</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#usestate"><span class="toc-number">1.2.1.</span> <span class="toc-text">useState</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%9B%B4%E6%96%B0"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">函数式更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B-state"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">惰性初始 state</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useeffect"><span class="toc-number">1.2.2.</span> <span class="toc-text">useEffect</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E9%99%A4-effect"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">清除 effect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#effect-%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">effect 的执行时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#effect-%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%89%A7%E8%A1%8C"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">effect 的条件执行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usecontext"><span class="toc-number">1.2.3.</span> <span class="toc-text">useContext</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E7%9A%84-hook"><span class="toc-number">1.3.</span> <span class="toc-text">额外的 Hook</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#usereducer"><span class="toc-number">1.3.1.</span> <span class="toc-text">useReducer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B-state"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">指定初始 state</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">惰性初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E8%BF%87-dispatch"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">跳过 dispatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87usecontext%E5%92%8Cusereducer%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E7%A7%8D%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">通过 useContext 和 useReducer 实现的一种状态管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useref"><span class="toc-number">1.3.2.</span> <span class="toc-text">useRef</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/react/react%20hooks/" rel="bookmark" title="react hooks">react hooks</a></li><li><a href="/react/create-react-app%E9%85%8D%E7%BD%AEless/" rel="bookmark" title="create-react-app配置less">create-react-app配置less</a></li><li><a href="/react/react%20%E7%AE%80%E6%98%93%E6%8A%98%E5%8F%A0%E9%9D%A2%E6%9D%BF/" rel="bookmark" title="react简易折叠面板实现">react简易折叠面板实现</a></li><li><a href="/react/react%20%E7%AE%80%E6%98%93%E7%89%88useState%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/" rel="bookmark" title="react 简易版useState实现方式">react 简易版useState实现方式</a></li><li><a href="/react/react%E8%87%AA%E5%AE%9A%E4%B9%89hook/" rel="bookmark" title="react自定义hook">react自定义hook</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="jluyeyu" data-src="/images/avatar.jpg"><p class="name" itemprop="name">jluyeyu</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">44</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">9</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">10</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL01lbW9yeU9mTG92ZQ==" title="https:&#x2F;&#x2F;github.com&#x2F;MemoryOfLove"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTEyNjE0OTAxOA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;126149018"><i class="ic i-cloud-music"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS9hbWVoaW1l" title="https:&#x2F;&#x2F;about.me&#x2F;amehime"><i class="ic i-address-card"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/typescript/ts%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/react/create-react-app%E9%85%8D%E7%BD%AEless/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/WebGL/" title="分类于 WebGL">WebGL</a></div><span><a href="/javascript/webgl/" title="WebGL基础">WebGL基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 interview">interview</a> <i class="ic i-angle-right"></i> <a href="/categories/interview/html/" title="分类于 html">html</a></div><span><a href="/interview/html/%E5%AF%B9%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E6%9C%89%E5%93%AA%E4%BA%9B/" title="对浏览器内核的理解及常见的浏览器内核有哪些？">对浏览器内核的理解及常见的浏览器内核有哪些？</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/project/" title="分类于 项目相关">项目相关</a> <i class="ic i-angle-right"></i> <a href="/categories/project/onlineResume/" title="分类于 在线简历生成">在线简历生成</a></div><span><a href="/project/onlineResume/4.%20%E9%A6%96%E9%A1%B5%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/" title="4. 首页框架搭建">4. 首页框架搭建</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/project/" title="分类于 项目相关">项目相关</a> <i class="ic i-angle-right"></i> <a href="/categories/project/onlineResume/" title="分类于 在线简历生成">在线简历生成</a></div><span><a href="/project/onlineResume/3.%20%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="3. 项目环境搭建">3. 项目环境搭建</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 interview">interview</a> <i class="ic i-angle-right"></i> <a href="/categories/interview/html/" title="分类于 html">html</a></div><span><a href="/interview/html/HTTP%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E7%94%A8%E9%80%94/" title="HTTP的几种常见请求方法用途">HTTP的几种常见请求方法用途</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/javascript/" title="分类于 javascript">javascript</a></div><span><a href="/javascript/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/" title="事件委托">事件委托</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/leetcode/" title="分类于 每日一题">每日一题</a></div><span><a href="/leetcode/76.%20%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/" title="76. 最小覆盖子串">76. 最小覆盖子串</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/typescript/" title="分类于 typescript">typescript</a></div><span><a href="/typescript/ts%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/" title="TypeScript学习笔记">TypeScript学习笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/project/" title="分类于 项目相关">项目相关</a> <i class="ic i-angle-right"></i> <a href="/categories/project/onlineResume/" title="分类于 在线简历生成">在线简历生成</a></div><span><a href="/project/onlineResume/2.%20hello%20webpack/" title="2. hello Webpack">2. hello Webpack</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/project/" title="分类于 项目相关">项目相关</a> <i class="ic i-angle-right"></i> <a href="/categories/project/onlineResume/" title="分类于 在线简历生成">在线简历生成</a></div><span><a href="/project/onlineResume/6.%20%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E5%92%8C%E6%95%B0%E6%8D%AE%E8%AE%BE%E8%AE%A1/" title="6. 通用组件和数据设计思想">6. 通用组件和数据设计思想</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">jluyeyu @ jluyeyu</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">210k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">3:11</span></div><div class="powered-by"><span class="exturl" data-url="aHR0cHM6Ly9iZWlhbi5taWl0Lmdvdi5jbi8=">辽ICP备2022000405号</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"react/react hooks/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>